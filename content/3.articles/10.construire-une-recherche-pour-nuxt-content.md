---
title: Construire une recherche pour Nuxt Content
description:
image: /assets/socials/index.png
cover:
  src:
  alt:
datePublished: 2023-10-17
dateModified: 2023-10-17
layout: article
---

<!-- il faut ajouter un lien vers une ressource github: https://github.com/barbapapazes/alpine-with-search -->
<!-- il faut ajouter des éléments à droite, comme UI -->

Une barre de recherche est un élément très apprécié des utilisateurs. En effet, elle permet de passer rapidement d'un contenu à un autre sans avoir à naviguer dans les menus. C'est donc un élément très important pour l'expérience utilisateur et s'assurer que les utilisateurs trouvent ce qu'ils cherchent, restant ainsi sur votre site.

Ainsi, dans cet article, nous allons voir comment construire une barre de recherche pour un site Nuxt Content. Avec l'arrivée de [Nuxt Studio](https://nuxt.studio), il n'a jamais été aussi simple de créer, utiliser et alimenter un site web comme un portfolio, un blog ou une documentation. Pour autant, ni Nuxt Content ni les différents templates proposés ne proposent de barre de recherche. Nous allons donc pallier à ce manque ensemble.

::alert{type="info"}
[Une PR est ouverte](https://github.com/nuxt/content/pull/2146) pour ajouter cette fonctionnalité directement au cœur de Nuxt Content.
::

## L'Idée Générale

Avant même de s'attaquer à créer une barre de recherche, comprenons la logique de ce que nous allons faire. En effet, il est important de comprendre ce fonctionnement pour pouvoir ensuite l'adapter au besoin du site ou s'il y a besoin d'utiliser un autre outil.

La recherche que nous allons construire est complètement côté-client, c'est-à-dire qu'il n'y a aucune requête à un serveur ou à une base de données. C'est un système très pratique lorsque le site est statique, que les données sont des fichiers markdown et qu'il n'y a pas de base de données.

<!-- il faut peut-être plus détailler cela -->

::alert{type="info"}
Il serait possible d'utiliser des outils comme [Algolia](https://www.algolia.com) pour construire une recherche côté serveur. Cependant, cela demande une configuration et un coût supplémentaire, notamment si vous avez beaucoup de contenu ou de sites à gérer.
::

### Les Outils à notre Disposition

Pour réaliser cette recherche, nous avons 2 outils à notre disposition :

- [Minisearch](https://lucaong.github.io/minisearch/), un moteur de recherche plein texte en mémoire, minuscule mais puissant, écrit en JavaScript.
- [Fuse.js](https://www.fusejs.io/), bibliothèque de recherche floue puissante et légère, sans aucune dépendance.

La différence entre les 2 est très minime. Pour notre cas, nous allons utiliser Minisearch parce que je le trouve plus simple à utiliser, à configurer et à personnaliser.

## Concrètement avec Nuxt et Content

Pour pouvoir réaliser une recherche, même côté-client, il est important d'avoir à disposition des données. Dans notre cas, il s'agit de l'ensemble du contenu de Nuxt Content.

Ensuite, il faut fournir ces données à Minisearch pour qu'il puisse effectuer la recherche à partir du mot clé saisi par l'utilisateur. Pour cela, et parce que nous générons notre site, nous allons créer un fichier JSON contenant l'ensemble des données de Nuxt Content. Par la suite, nous allons pouvoir récupérer ce fichier JSON et l'utiliser pour construire notre recherche.

Pour créer notre fichier JSON, nous allons utiliser la partie serveur de Nuxt. En créant un nouveau point d'accès à notre site, nous allons pouvoir récupérer l'ensemble des données de Nuxt Content et les transformer en JSON. Grâce au pré-rendu, nous allons pouvoir générer ce fichier JSON à la construction du site, nous permettant de ne pas avoir à le générer à chaque fois que l'utilisateur effectue une recherche, évitant ainsi l'utilisation d'un serveur.

::alert{type="info"}
Pour en savoir plus sur [la partie serveur de Nuxt](https://nuxt.com/docs/getting-started/server).
::

<!-- il va manquer une partie sur le fait qu'on va le faire sur alpine et tout -->

## Créer le fichier JSON

Dans un premier temps, nous allons créer le fichier JSON qui contiendra l'ensemble des données de Nuxt Content. Pour cela, nous allons créer un nouveau point d'accès à notre site. Nous verrons comment optimiser les performances en pré-rendant ce fichier JSON et en l'indexant.

### Créer le point d'accès

Avant tout, créons notre point d'accès `server/api/search.ts` :

```ts [server/api/search.ts]
export default defineEventHandler(async (event) => {
  return 'Hello search'
});
```

Nous pouvons tester notre point d'accès en lançant notre serveur de développement et en allant sur `http://localhost:3000/api/search`.

### Parser le Contenu de Nuxt Content

Ensuite, nous devons récupérer l'ensemble du contenu de Nuxt Content. C'est super simple parce que Nuxt Content fonctionne avec le côté serveur de Nuxt et qu'une fonction est à disposition pour cela.

```ts [server/api/search.ts]
import { serverQueryContent } from '#content/server'

export default defineEventHandler(async (event) => {
  const files = await serverQueryContent()
  return files
});
```

En actualisant notre navigateur, nous pouvons alors voir l'ensemble du contenu de Nuxt Content. Parfait !

::detail{title="À quoi ressemble un fichier de Nuxt Content ?"}

Voici à quoi ressemble la structure d'un fichier de Nuxt Content après avoir été parsé :

```json
{
  "parsed": {
    "_path": "/...",
    "_dir": "articles",
    "_draft": false,
    "_partial": false,
    "_locale": "",
    "_empty": false,
    "title": "...",
    "description": "...",
    "image": "...",
    "cover": {
      "src": "...",
      "alt": "..."
    },
    "datePublished": "...",
    "dateModified": "...",
    "layout": "article",
    "body": {
      "type": "root",
      "children": [
        {
          "type": "element",
          "tag": "h2",
          "props": {
            "id": "introduction"
          },
          "children": [
            {
              "type": "text",
              "value": "Introduction"
            }
          ]
        },
        {
          "type": "element",
          "tag": "p", // Une balise <p> avec une <a> à l'intérieur contenant le texte "Nitro"
          "props": {},
          "children": [
            {
              "type": "element",
              "tag": "a", // Une balise <a> avec différents attributs dans props
              "props": {
                "href": "...",
                "rel": [
                  "nofollow"
                ]
              },
              "children": [
                {
                  "type": "text",
                  "value": "Nitro"
                }
              ]
            },
          ]
        }
      ]
    }
  }
}
```

La partie intéressante se trouve dans la clé `body`. C'est ici que se trouve le contenu du fichier markdown. Nous remarquons qu'il s'agit d'un AST (Abstract Syntax Tree) qui est une représentation abstraite du contenu. C'est un format très pratique pour manipuler le contenu et le transformer. Il est intéressant de noter le côté récursif de la structure permettant de la parcourir simplement.
::

Désormais, nous allons devoir travailler ce contenu un peu pour ne garder que les fichiers markdown et retirer ceux en cours de rédaction ou vide.

```ts [server/api/search.ts]
import { serverQueryContent } from '#content/server'

export default defineEventHandler(async (event) => {
  const files = await serverQueryContent()
  const markdownFiles = filter(file => file._extension === 'md' && !file?._draft && !file?.empty)
  return markdownFiles
});
```

Ensuite, nous allons devoir extraire et formatter le contenu de chaque fichier markdown. Le coeur de la recherche se trouve dans la prochaine fonction. L'idée est la suivante, à faire sur l'ensemble des fichiers :

- Découpage du contenu en sections (à chaque titre)
- Création de l'URL, `/<path>#<section_id>`, pour chaque section
- Extraction du contenu de chaque section pour ne garder que le texte intéressant. Par exemple, il n'est pas pertinent de conserver le contenu des balises `code` ou `style`.

<!-- mettre le type d'une section ici -->

Dans un premier temps, traitons le `body` dans un fichier `server/utils/search.ts` :

```ts [server/utils/search.ts]
import type { MarkdownNode } from '@nuxt/content/dist/runtime/types'

const UNWANTED_TAGS = ['code', 'style']

function extractTextFromAst(node: MarkdownNode) {
  let text = ''

  // Get text from markdown AST
  if (node.type === 'text')
    text += node.value

  // Do not explore unwanted children
  if (UNWANTED_TAGS.includes(node.tag))
    return ''

  // Explore children
  if (node.children) {
    for (const child of node.children)
      text += ` ${extractTextFromAst(child)}`
  }

  // Trim text to avoid extra spaces
  return text.trim()
}
```

Si nous tombons sur un noeud de type `text`, nous récupérons sa valeur. Si nous tombons sur un noeud de type `code` ou `style`, nous ne l'explorons pas parce que le contenu ne nous intéresse pas. Enfin, si nous tombons sur un noeud avec des enfants, nous les explorons.

::alert{type="info"}
Il est intéressant de noter qu'il est possible de modifier les tags à ne pas explorer. Par exemple, si vous souhaitez conserver le contenu des balises `code`, il suffit de retirer `code` du tableau `UNWANTED_TAGS`. Au contraire, si vous souhaitez retirer le contenu des balises `a`, il suffit de l'ajouter au tableau.
::

Ensuite, nous allons devoir découper nos pages en sections. Pour cela,

### Indexer le fichier JSON

<!-- charger dans une instance minisearch, stringify retourner (penser à mettre un lien vers la documentation -->

### Pré-rendu

<!-- ajouter la bonne règle dans les routesRules -->

## Créer la barre de recherche

## Conclusion


<!--
Expliquer pourquoi on veut une recherche locale (et présenter Algolia mais complexe à configurer)

Faire une démo sur Alpine car c'est le plus amusant.
- Fonctionnement général
- Server side

Créer un endpoint qui va retourner le JSON.

- Client side

Ne pas ajouter une modale mais créer une nouvelle page.

Fetch le JSON (bien faire une partie sur le serveur ou non) et montrer l'impact sur le payload.json (faire un autre article sur l'ajout d'une modale et les paramètres auxquels il faut faire attention) (montrer plusieurs types de recherche pour démontrer à quel point on peut personnaliser la chose).

- Enfin, c'est bien.
-->
