---
title:
description:
image: /assets/socials/index.png
cover:
  src:
  alt:
datePublished: 2023-10-06
dateModified: 2023-10-06
layout: article
---

Nuxt, Next, Remix, SveltKit ou même Solid Start ont un point commun. Après avoir conquis le front-end, ils s'attaquent à la partie back-end du web et tentent de devenir de véritables frameworks full-stack. Mais qu'en est-il aujourd'hui et où en sont-ils par rapport aux frameworks full-stack déjà présents, comme AdonisJS, Laravel ou Rails, originellement plus axés sur le back-end que le front-end et matures.

Avec cette article, nous allons spécifiquement nous intéresser au cas de Nuxt. Cependant, ce que nous allons voir pourrait s'appliquer à d'autres frameworks front-end s'essayant au full-stack.

Avant même de discuter de l'état de Nuxt sur son chemin vers le full-stack, il est important de bien comprendre ce qu'est une application full-stack et les implications de cette appellation.

## Une application full-stack

Il existe plusieurs définition du full-stack.

En prenant la [définition de développeur full-stack de Wikipédia](https://fr.wikipedia.org/wiki/D%C3%A9veloppeur_full_stack), cela fait référence à un développeur capable de tout faire, des interactions clientes, au développement du logiciel à la configuration de l'infrastructure. C'est une définition qui est très large et qui ne nous intéresse pas ici d'autant qu'elle fait référence à un développeur et non à un framework.

En cadrant la définition à un framework, nous pouvons considérer le full-stack comme étant le fait de s'occuper à la fois au front-end et au back-end de l'application. C'est à dire qu'avec le même outil, il nous est possible de réaliser la présentation des données à l'utilisateur tout en interagissant avec la base de données, au moins d'une API ou non. C'est ce que permettent des outils comme [:icon{name="laravel"} Laravel](https://laravel.com), [:icon{name="rails"} Ruby on Rails](https://rubyonrails.org/) ou [:icon{name="adonisjs"} AdonisJS](https://adonisjs.com).

<!-- parler qu'il faut déployer sur un vps, que c'est pas si simple parce que après il faut gérer le vps et c'est tout comme la db qu'il faut aussi gérer et tout et tou -->

<!-- il manque une partie sur le fait que l'on mettre en production notre application simplement et faire le lien avec le fait que l'on part ensuite du on edge -->

## Les changements depuis Nuxt 2

Cet article n'aurait pas été possible, ou n'aurait eu que peu d'intérêt, il y a 2 ans, avant le lancement de Nuxt 3 et l'arrivé des edge functions.

D'une part, Nuxt, jusqu'à sa version 2, ne permettait pas d'interagir simplement avec un serveur et une base de données. Pour utiliser le serveur, il fallait mettre en place un [ "server middleware"](https://v2.nuxt.com/docs/configuration-glossary/configuration-servermiddleware).

D'autres part, le déploiement de Nuxt 2 sur un serveur était limité et les plateformes proposant des serverless functions n'étaient pas encore très répandues et encore très jeune.

- [Cloudflare a sorti ses Workers en mars 2018](https://blog.cloudflare.com/introducing-cloudflare-workers/)
- Netlify a annoncé ses [serverless functions en avril 2021](https://www.netlify.com/blog/2021/04/19/announcing-native-typescript-support-for-netlify-functions/) et ses [edge functions en avril 2022](https://www.netlify.com/blog/announcing-serverless-compute-with-edge-functions/)
- Vercel a annoncé ses [edge functions en décembre 2022](https://vercel.com/blog/edge-functions-generally-available)

Ces dates sont importantes parce qu'elles marquent l'arrivé des edge functions.

### Serverless function vs Edge function

<!-- il faut inscister sur le fait que les edge function ont changé la donne en simplifiant la gestion de l'infrastructure -->

Les edge functions sont des serverless functions dans la mesure où elles s’exécutent sur un server géré par un tier et qui se déclenchent à la réception d'une requête HTTP. La grande différence est l’exécution des edge functions sur un CDN et non sur un serveur distant. Cela permet d'avoir des temps de réponse très faible et de pouvoir les utiliser pour des tâches qui nécessitent une réponse rapide.

Cet avantage vient avec un inconvénient. Les edge functions sont limitées en terme de ressources et de temps d'exécution. Là où une edge function peut s'exécuter en moins de 10ms, une serverless function peut mettre plusieurs secondes à s'exécuter comme le montre [cette comparaison sur AWS, Azure et GCP des démarrages à froid](https://mikhail.io/serverless/coldstarts/big3/) mais une edge function ne peut pas faire plus de 1MB, _node\_modules inclus_.

Du coup, les serverless functions, pour permettre à une application d'être rendu côté server, c'est pas idéal parce que le temps de réponses est trop long. En revanche, les edge functions, s'y prêtent beaucoup mieux, à condition de réussir à faire rentrer son application dans les 1MB et son temps d'exécution dans les 10ms, ce qui n'a rien d'une tâche facile.

Ainsi, mettre en production une application full-stack avec des

### Nuxt 3

En novembre 2022, [Nuxt 3 est annoncé](https://nuxt.com/blog/v3) et avec lui, l'arrivé de [Nitro](https://github.com/unjs/nitro). L'air de rien, Nuxt 3 change la donne en permettant de créer simplement une partie serveur au sein de son projet tout en pouvant ensuite déployer son application n'importe où, y compris [sur l'edge](https://nuxt.com/blog/nuxt-on-the-edge) sans rien changer à son code. C'est une révolution.

### Edge Database

Avoir son serveur au plus près du client, c'est une bonne chose mais si la requête pour récupérer les données doit faire le tour du monde, cela ne sert pas à grand chose et c'est là qu'intervient l'edge database.

- [Cloudflare annonce D1 en novembre 2022](https://blog.cloudflare.com/introducing-d1/)
- [Neon annonce une serverless Postgre en décembre 2022](https://neon.tech/blog/neon-serverless-postgres-is-live)
- [En janvier 2023, Turso est annoncé](https://blog.turso.tech/announcing-chiselstrike-turso-164472456b29)


## VPS Ou On Edge

<!-- peut être qu'on n'a pas besoin de cette partie dans la suite -->

### Un petit exemple

Pour bien comprendre ce dont on va parler dans la suite de cette article, prenons un exemple qui nous servira de fil rouge.

Nous sommes un développeur web et nous souhaitons créer une application permettant de raccourcir une URL en utilisant un mot personnalisé. Via un formulaire sur une interface web, il serait possible de définir une clé associé à une URL. En partageant une URL avec cette clé, l'utilisateur sera redirigé vers l'URL associé. Par exemple, notre application pourrait être sur le domaine 'https://s.example.com". Nous associons le mot "unjs" à l'URL "https://unjs.io" et lorsque l'utilisateur se rend sur l'URL "https://s.example.com/r/unjs", il est redirigé vers "https://unjs.io". Ce système permettrait de compatbilité le nombre d'utilisation de l'URL et la provenance.

Pour mener à bien cet exemple, creusons un peu plus la technique nécessaire. Dans un premier temps, il va nous falloir une base de données pour stocker les mots clés associés aux URLs et l'activité sur chacun de ses URL. Ensuite, nous allons avoir besoin d'un moyen pour valider les données transmise par le formulaire au serveur. Nous allons avoir besoin de vérifier la présence du mot clé et de l'URL, que l'URL est bien une URL et que le mot clé n'est pas déjà utilisé. Enfin, nous allons devoir protéger l'interface d'administration pour éviter à n'importe qui de pouvoir créer ou supprimer des mots clés et l'URL associé.

### Les besoins

partir de l'exemple pour expliquer les besoins tant en dev que en prod

plus tard, donner d'autres exemple comme la migration des données, les autorizations, l'Internationalisation, la gestion des fichiers...

// on peut aussi évoquer le fait qu'on va avoir besoin de se concentrer sur la partie business et pas de passer 3h à tout configurer.

Pour construire une application full-stack sur le long terme et qui puisse évoluer, nous allons avoir besoin de beaucoup de choses.

// peut être prendre un example de ce que l'on aimerait constuire

#### Base de données

Pour créer une application réellement utilisable, les éléments permettant de faire le lien avec la base de données sont très importants.

#### Validation des données

// ajouter pour chacune de ces parties des explication sur ce à quoi ça va servir dans la vraie vie

- Routage HTTP
- Téléversement de fichiers
- Gestion des sessions utilisateurs
- Création des vues utilisateurs
- Validation des données des formulaires
- Intéraction avec la base de données
- Ensemencement de la base de données
- Migration du schéma
- Actions en fonction d'évènement sur les modèles
- Sérialisation des modèles
- Authentification via cookies, tokens ou navigateur
- Authorisation
- Internationalisation
- Gestion des fichiers téléversés
- Health check
- Limitation des requêtes



## Conclusion

le but ce n'est pas de dire que nuxt c'est null mais c'est de faire un point d'étape sur là où on en est dans le monde du dev web



- mon passage à UnJS et mon petit côté R&D (et visualisation de la vidéo de Pooya avec db0 et Sebatian avec neo et nuxt-todos-edge)
- la philosophy de nuxt (universel)
- ce qu'il nous faut pour construire une application full stack
- ce qu'on a actuellement et ce qu'il nous manque
- conclusion positive et redirection vers la démo du personal urls shortener
