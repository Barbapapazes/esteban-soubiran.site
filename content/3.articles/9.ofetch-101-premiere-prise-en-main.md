---
title: ofetch 101 - Première prise en main
description: Découvrez ofetch, une meilleure API pour fetch, fonctionne sur le navigateur, Node.js et les workers.
image: /assets/socials/ofetch-101-premiere-prise-en-main.jpg
cover:
  src: /assets/articles/ofetch-101-premiere-prise-en-main/cover.webp
  alt: Image d'illustration de l'article ofetch 101 - Première prise en main
datePublished: 2023-07-19
dateModified: 2023-07-19
layout: article
---

## Introduction

[`ofetch`](https://github.com/unjs/ofetch) est un utilitaire permettant de réaliser des requêtes HTTP. Il a la particularité de fonctionner aussi bien dans un navigateur, que dans un environnement Node.js ou dans un worker en améliorant et uniformisant l'API.

Il fait parti de l'écosystème UnJS.

Retrouver le code source de cet article :git-hub-link{repo="barbapapazes/ofetch-101-first-hand"}

### UnJS, c'est quoi ?

[UnJS](https://unjs.io), c'est un écosystème d'outils JavaScript. L'objectif est de fournir des outils qui ne font qu'une seule chose mais qui la font très bien et qui peuvent être combinés entre eux pour créer des outils plus complexes.

UnJS suit [la philosophie UNIX](http://www.catb.org/~esr/writings/taoup/html/ch01s06.html) : _"Faites une chose et faites le bien"_. Ainsi, la plupart des outils UnJS sont des outils avec très peu de fonctionnalités mais dont la force réside dans la modularité avec d'autres outils. À l'origine du projet, il y a [Pooya "Pi0" Parsa](https://github.com/pi0) développeur chez [NuxtLabs](https://github.com/nuxtlabs) et leader de :icon{name="nuxt"} [Nuxt] des premiers commits à son lancement officiel !

Chacun des projets est maintenu par son auteur et des mainteneurs désignés.

Pour en savoir plus, nous pouvons [lire leur gouvernance](https://github.com/unjs/governance).

## La problématique

Pour bien comprendre la problématique qui est adressée par `ofetch`, voyons quelques exemples.

Dans un navigateur, pour réaliser une requête HTTP, nous utilisons l'API [`fetch`](https://developer.mozilla.org/fr/docs/Web/API/Fetch_API/Using_Fetch) :

```js
fetch('https://example.com')
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error(error))
```

Dans Node.js, jusqu'à la version 16.15.0, il n'y avait pas d'API native pour réaliser des requêtes HTTP. Il fallait utiliser un paquet externe comme `node-fetch` :

```js
import fetch from 'node-fetch'

fetch('https://example.com')
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error(error))
```

Les 2 examples ci-dessus sont très similaire. Cependant, dans le cas de Node.js, il faut importer le paquet `node-fetch` et dans le cas du navigateur, il faut utiliser l'API native `fetch`.

Cette différence est significative lorsque nous voulons écrire du code qui fonctionne à la fois dans un navigateur et dans Node.js et c'est la problématique que les équipes de :icon{name="nuxt"} Nuxt ont rencontré.

En effet, Nuxt se dit universel dans le sens où le code écrit par un développeur peut aussi bien tourner côté server, pour le SSR, que dans le navigateur, pour la SPA. Ainsi, il est important que les appels HTTP fonctionnent dans les 2 environnements.

Dans le même temps, le support de `fetch` dans Node.js est arrivé dans la version 18.0.0. `fetch` devient donc encore plus universel.

Pour autant `ofetch` apporte des fonctionnalités supplémentaires qui le rendent plus intéressant que `fetch` et c'est ce que nous allons découvrir.

## Installation

Pour commencer, initialisons un projet en créant un nouveau dossier :

```bash
mkdir ofetch-101
cd ofetch-101
npm init -y
```

Ensuite, nous allons installer `ofetch` :

```bash
npm install ofetch
```

Pour faciliter l'exécution de nos fichiers :icon{name="typescript"} TypeScript, nous allons installer [`jiti`](https://github.com/unjs/jiti) :

```bash
npm install -D jiti
```

<!-- :another-article{name="jiti-101-premiere-prise-en-main"} -->

Pour finir, nous allons créer le dossier `src` qui contiendra toutes nos sources :

```bash
mkdir src
```

## Première utilisation

::alert{type="info"}
Dans l'ensemble de ce tutoriel, nous allons utiliser l'API de GitHub pour récupérer des informations réelles et rendre le tutoriel plus intéressant. :warning: Lorsque vous n'êtes pas authentifié, GitHub limite à [60 requêtes par heure](https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#rate-limiting).
::

Utiliser `ofetch` est très simple. Il suffit de l'importer et de passer l'URL de la ressource à récupérer. Pour commencer, créons un fichier `first-request.ts` dans le dossier `src`. Avec de fichier, nous allons afficher le nombre d'étoiles du projet `unjs/ofetch` :

```ts [first-request.ts]
import { ofetch } from 'ofetch'

async function main() {
  const data = await ofetch('https://api.github.com/repos/unjs/ofetch') // On fait une requête sur l'API de GitHub

  console.log(data.stargazers_count) // On affiche le nombre d'étoiles du projet
}

main().catch(console.error)
```
_Super simple !_

### Typage

C'est super mais `data` est du type `any`. Nous n'avons donc pas d'autocomplétion et :icon{name="typescript"} TypeScript ne peut pas nous aider à détecter les erreurs.

Pour palier cela, il est possible de passer un type personnalisé à `ofetch`. Pour faire cela, créons un fichier `types.ts` dans le dossier `src` dans lequel nous allons définir une partie du type du retour de l'API de GitHub :

```ts [types.ts]
export interface Repository {
  stargazers_count: number
}
```

Ensuite, nous pouvons simplement utiliser le type `Repository` dans notre fichier `first-request.ts` :

```ts [first-request.ts]
import { ofetch } from 'ofetch'
import type { Repository } from './types'

async function main() {
  const data = await ofetch<Repository>('https://api.github.com/repos/unjs/ofetch') // On fait une requête sur l'API de GitHub

  console.log(data.stargazers_count) // On affiche le nombre d'étoiles du projet
}

main().catch(console.error)
```

Maintenant, `data` est du type `Repository` et nous avons donc l'autocomplétion et :icon{name="typescript"} TypeScript peut nous aider à détecter les erreurs.

::alert{type="warning"}
:warning: Le type ne vérifie pas le retour. Si une propriété change lors du retour, le type ne nous avertira pas.

Pour s'assurer que le retour contient bien toutes les propriétés attendues, il est possible d'utiliser une solution comme [`zod`](https://zod.dev/) ou [`vinejs`](https://vinejs.dev) (ne fonctionne que sur Node.js).
::

### Parsing automatique

Affichons tout l'objet `data` :

```ts [first-request.ts]
// ...

async function main() {
  const data = await ofetch<Repository>('https://api.github.com/repos/unjs/ofetch')

  // ...

  console.log(data)
}

// ...
```

Nous pouvons voir que `data` est déjà parsé en JSON et c'est pour cela que nous avons pu accéder à la propriété `stargazers_count` sans avoir à faire `data.json().stargazers_count` comme cela peut être le cas avec `fetch`.

`ofetch` va parser la réponse automatiquement en JSON et s'il échoue, il renvoie le texte. Cela est possible grâce à l'utilisation de `destr`. Ainsi, le code écrit avec `ofetch` est plus court et plus lisible.

:another-article{name="destr-101-premiere-prise-en-main"}

### Parsing manuel

Pour autant, il reste possible d'indiquer manuellement à `ofetch` la manière dont il doit se comporter. Pour voir cela, créons un nouveau fichier `manual-parsing.ts`, similaire à `first-request.ts`, dans le dossier `src` :

```ts [manual-parsing.ts]
import { ofetch } from 'ofetch'
import type { Repository } from './types'

async function main() {
  const data = await ofetch<Repository>('https://api.github.com/repos/unjs/ofetch', { parseResponse: txt => txt })

  console.log(data)
}

main().catch(console.error)
```

`parseResponse` prend une fonction dont le paramètre est le texte de la réponse et le retour est le résultat de la transformation que nous souhaitons appliquer. Dans notre cas, nous venons simplement sur-charger le comportement par défaut pour que `ofetch` ne parse pas la réponse en JSON. Nous retourns la réponse brute.

Par défaut, `ofetch` va utiliser `destr` mais en utilisant cette option, il serait possible d'utiliser `JSON.parse` ou n'importe quelle autre fonction de parsing qui conviendrait mieux à notre cas d'utilisation.

Il est aussi possible de jouer avec l'option `responseType` pour définir comment `ofetch` doit traiter le retour. Il est possible d'utiliser :

- `text` pour avoir le texte brut
- `json` pour avoir le JSON parsé
- `blob` pour avoir un `Blob`
- `arrayBuffer` pour avoir un `ArrayBuffer`
- `stream` pour avoir un `ReadableStream`

Par exemple, si nous voulons récupérer le texte brut, nous pouvons faire :

```ts [manual-parsing.ts]
// ...

async function main() {
  const data = await ofetch<Repository, 'text'>('https://api.github.com/repos/unjs/ofetch', { responseType: 'text' })

  console.log(data)
}

// ...
```

## Options

`ofetch`, tout comme `fetch` supporte tout un tas d'options pour nous permettre personnaliser notre requête.

### Base URL

Il est possible de définir une URL de base pour la requête. Cela est pratique pour stocker dans une variable ou une variable d'environnement l'URL de base de notre API.

Pour tester cela, créons un nouveau fichier `base-url.ts` dans le dossier `src`. Dans notre cas, nous savons que l'URL de base de l'API de GitHub est `https://api.github.com`. Nous allons donc pouvoir la stocker dans une variable dans un fichier `constants.ts` dans le dossier `src` :

```ts [constants.ts]
export const GITHUB_API_BASE_URL = 'https://api.github.com'
```

Ensuite, créons notre requête dans le fichier `base-url.ts` pour récupérer les informations du projet `ofetch` :

```ts [base-url.ts]
import { ofetch } from 'ofetch'
import { GITHUB_API_BASE_URL } from './constants'

async function main() {
  const data = await ofetch(`/repos/unjs/ofetch/tags`, { baseURL: GITHUB_API_BASE_URL }) // Nous récupérons les tags du projet.

  console.log(data)
}

main().catch(console.error)
```

Cette méthode est très pratique pour éviter de répéter l'URL de base dans toutes nos requêtes et ainsi pouvoir la changer très simplement. Par exemple, lors du développement, nous ne voulons pas nécessairement taper directement sur l'API de production mais sur l'API de développement. Nous pouvons donc changer la valeur de `GITHUB_API_BASE_URL` pour pointer sur l'API de développement.

::alert{type="info"}
Dans un cas réel, nous aurons récupérer la valeur de `GITHUB_API_BASE_URL` depuis une variable d'environnement.
::

#### Notre instance sur mesure

Il est possible d'aller encore plus loin en créant notre propre instance de `ofetch` avec la méthode `create` en lui passant des options par défaut. Dans notre cas, nous allons créer un `ofetch` avec une URL de base pointant sur l'API de GitHub dans le fichier `constants.ts` :

```ts [constants.ts]
import { ofetch } from 'ofetch'

export const GITHUB_API_BASE_URL = 'https://api.github.com'

export const githubFetch = ofetch.create({ baseURL: GITHUB_API_BASE_URL })
```

Retournons dans le fichier `base-url.ts` pour utiliser notre instance de `ofetch`, où nous n'avons plus besoin d'importer `ofetch` ni `GITHUB_API_BASE_URL` :

```ts [base-url.ts]
import { githubFetch } from './constants'

async function main() {
  const data = await githubFetch('/repos/unjs/ofetch/tags')

  console.log(data)
}

main().catch(console.error)
```

L'utilisation de la méthode `create` permet d'avoir un code plus lisible et plus court tout en s'assurant que l'ensemble des appels à l'API de GitHub utilise bien la même URL de base (et d'autres options par défaut qu'il est possible de définir).

### Méthodes

`ofetch` supporte toutes les méthodes HTTP. Par défaut, `ofetch` utilise la méthode `GET` mais il est possible de changer cela en utilisant l'option `method` :

```ts [method.ts]
import { ofetch } from 'ofetch'

async function main() {
  const data = await ofetch('https://api.github.com/repos/unjs/ofetch', { method: 'POST' })

  console.log(data)
}

main().catch(console.error)
```

Cette exemple ne fonctionne pas car l'API de GitHub ne connaît pas la méthode `POST` sur cette route. Nous obtenons donc une erreur `400 Bad Request`.

Les méthodes HTTP supportées par `ofetch` sont :

- `GET`
- `POST`
- `PUT`
- `PATCH`
- `DELETE`
- `HEAD`
- `OPTIONS`

### Body

Il est possible d'envoyer un `body` dans une requête pour transmettre des informations au serveur. Pour cela, nous allons convertir du markdown en HTML à l'aide de l'API de GitHub. Créons un fichier `body.ts` dans le dossier `src` :

```ts [body.ts]
import { githubFetch } from './constants'

async function main() {
  const data = await githubFetch('/markdown', {
    method: 'POST',
    body: {
      text: '# Hello world\n\nThis is a **test**',
    },
  })

  console.log(data)
}

main().catch(console.error)
```

L'API nous retourne le HTML correspondant au markdown envoyé dans le `body` de la requête.

```html
<h1><a id="user-content-hello-world" class="anchor" aria-hidden="true" href="#hello-world"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hello world</h1>
<p>This is a <strong>test</strong></p>
```

Le `body` peut être de plusieurs types :

- `string`
- `FormData`
- `URLSearchParams`
- `Blob`
- `BufferSource`
- `ReadableStream`
- `Record<string, any>`

### Headers

Il est possible d'ajouter des `headers` à la requête avec `ofetch`. Par exemple, si nous souhaitons nous authentifier à l'API de GitHub, nous devons ajouter un `header` `Authorization` avec la valeur `token <token>` où `<token>` est le token d'authentification. Créons un fichier `headers.ts` dans le dossier `src` :

```ts [headers.ts]
import { githubFetch } from './constants'

async function main() {
  const data = await githubFetch('/user', {
    headers: {
      Authorization: `token ${process.env.GITHUB_TOKEN}`,
    },
  })

  console.log(data)
}

main().catch(console.error)
```

Si nous n'ajoutons pas de token d'authentification, nous obtenons une erreur `401 Unauthorized`.

Autrement, ce header est une information très intéressant à placer dans notre instance de `ofetch` pour éviter d'avoir à la répéter dans toutes nos requêtes. Aussi, récupérer le token via une variable d'environnement ne permettra pas l'exécution de ce code sur un navigateur.

### Query string

Il est possible d'ajouter des paramètres à la requête avec `ofetch`. Par exemple, si nous souhaitons récupérer les tags d'un dépôt, nous devons ajouter un paramètre `per_page` avec la valeur `2`. Créons un fichier `query-string.ts` dans le dossier `src` :

```ts [query-string.ts]
import { githubFetch } from './constants'

async function main() {
  const data = await githubFetch('/repos/unjs/ofetch/tags', {
    query: {
      per_page: 2,
    },
  })

  console.log(data)
}

main().catch(console.error)
```

On peut voir que la réponse ne contient que deux tags. :mage:

### Retry

Lorsqu'une requête échoue, il est possible de la relancer automatiquement avec `ofetch`. Pour cela, il faut utiliser l'option `retry` qui attend un nombre de tentatives à effectuer avant de lever une erreur.

Par défaut, le `retry` est à 1 sauf pour les méthodes `POST`, `PUT`, `PATCH` et `DELETE` où il est à 0.

Un retry se produit lorsque le code de statut est l'un de :

- `408 Request Timeout`
- `409 Conflict`
- `425 Too Early`
- `429 Too Many Requests`
- `500 Internal Server Error`
- `502 Bad Gateway`
- `503 Service Unavailable`
- `504 Gateway Timeout`

Autrement, aucun retry n'est effectué.

### Cookies

Il n'est pas possible d'envoyer un cookie. Cependant, il est possible de changer le comportement du navigateur avec `credentials`. Par défaut, `credentials` est à `same-origin` mais il peut être changé pour `include` ou `omit`.

::alert{type="info"}
Pour en savoir plus sur les cookies, vous pouvez lire [cet article](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies).
::

## Une réponse complète

Depuis le début, nous avons pu observer que la réponse de `ofetch` est le corps de la réponse du serveur. Pour autant, il existe des cas où nous avons besoin d'avoir accès à tout la requête.

Pour cela, il est possible d'utiliser la méthode `raw` qui retourne un objet contenant la réponse :

```ts [raw.ts]
import { githubFetch } from './constants'

async function main() {
  const response = await githubFetch.raw('/repos/unjs/ofetch/tags')

  console.log(response)
}

main().catch(console.error)
```

On observe les `headers`, le `body` et le `status` de la réponse.L'objet `response` est une [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response).

## Gestion des erreurs

Lorsque la réponse du server n'est pas `ok`, `ofetch` lève une erreur. Par exemple, si nous essayons d'accéder à un dépôt qui n'existe pas, nous obtenons une erreur `404 Not Found` que nous pouvons simplement traiter :

```ts [error.ts]
import { githubFetch } from './constants'

async function main() {
  try {
    const data = await githubFetch('/repos/unjs/ofetch-404/tags')

    console.log(data)
  } catch (error) {
    console.error(error.data)
  }
}

main().catch(console.error)
```

## Interceptions des requêtes et des réponses

La dernière fonctionnalité offerte par `ofetch` est la possibilité de se brancher sur les requêtes et les réponses.

Pour cela, il suffit de passer différentes méthodes dans les options de `ofetch` :

- `onRequest` : appelée avant l'envoi de la requête
- `onRequestError` : appelée en cas d'erreur lors de l'envoi de la requête
- `onResponse` : appelée après la réception et le parsing de la réponse
- `onResponseError` : appelée après la réception si `response.ok` est `false`

Ces méthodes sont utilisées pour ajouter des paramètres aux requêtes, logger les erreurs ou encore ajouter des informations aux réponses.

Par exemple, si nous souhaitons logger les requêtes et les réponses, nous pouvons utiliser le code suivant :

```ts [intercept.ts]
import { githubFetch } from './constants'

async function main() {
  const data = await githubFetch('/repos/unjs/ofetch/tags', {
    query: {
      per_page: 1
    },
    onRequest: ({ request, options }) => {
      console.log('Request', request, options)
    },
    onRequestError: ({ request, options, error }) => {
      console.error('Request error', error)
    },
    onResponse: ({ request, options, response }) => {
      console.log('Response', response, options)
    },
    onResponseError: ({ request, options, response }) => {
      console.error('Response error', error)
    },
  })

  console.log(data)
}

main().catch(console.error)
```

Simple et efficace !

## Conclusion

<!-- dire que c'est beaucoup plus puissant que juste fetch en citant les différents exemples -->
<!-- faire le visuel -->
<!-- faire le readme dans le repo first-hand et penser à push -->
