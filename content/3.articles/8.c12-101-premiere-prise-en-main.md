---
title: C12 101 - Première prise en main
description: Découvrez C12, l'utilitaire pour charger des configurations intelligemment.
image: /assets/socials/c12-101-premiere-prise-en-main.jpg
cover:
  src: /assets/articles/c12-101-premiere-prise-en-main/cover.webp
  alt: Image d'illustration de l'article C12 101 - Première prise en main
datePublished: 2023-07-12
dateModified: 2023-07-12
layout: article
---

<!-- retravailler les outils avec des problématiques pour mettre le paragraphe avant l'installation -->

## Introduction

[`C12`](https://github.com/unjs/c12) est un outil permettant de charger intelligemment des configurations dans un projet pour le paramétrer en utilisant les valeurs de l'utilisateur.

Il se base sur des outils comme [`defu`](https:/github.com/unjs/defu) et [`rc9`](https://github.com/unjs/rc9) pour proposer une solution simple et efficace.

Retrouver le code source de cet article :git-hub-link{repo="barbapapazes/c12-101-first-hand"}

### UnJS, c'est quoi ?

[UnJS](https://unjs.io), c'est un écosystème d'outils JavaScript. L'objectif est de fournir des outils qui ne font qu'une seule chose mais qui la font très bien et qui peuvent être combinés entre eux pour créer des outils plus complexes.

UnJS suit [la philosophie UNIX](http://www.catb.org/~esr/writings/taoup/html/ch01s06.html) : _"Faites une chose et faites le bien"_. Ainsi, la plupart des outils UnJS sont des outils avec très peu de fonctionnalités mais dont la force réside dans la modularité avec d'autres outils. À l'origine du projet, il y a [Pooya "Pi0" Parsa](https://github.com/pi0) développeur chez [NuxtLabs](https://github.com/nuxtlabs) et leader de :icon{name="nuxt"} [Nuxt] des premiers commits à son lancement officiel !

Chacun des projets est maintenu par son auteur et des mainteneurs désignés.

Pour en savoir plus, nous pouvons [lire leur gouvernance](https://github.com/unjs/governance).

## La problématique

Imaginons que nous voulions créer le prochain framework :icon{name="vue"} Vue.js.

:another-article{name="le-prochain-framework-vue"}

Pour cela, nous allons devoir utiliser différents outils comme :icon{name="vue"} Vue.js, :icon{name="vite"} et Nitro. Chacun de ses outils, nous allons devoir les configurer pour qu'ils fonctionnent ensemble. Dans le même temps, nous allons devoir permettre à l'utilisateur de configurer notre framework et les outils qu'il utilise pour qu'il puisse les personnaliser selon ses besoins.

::alert{type="info"}
Par exemple, il est important pour l'utilisateur de pouvoir changer le port sur lequel le serveur va écouter.
::

Pour configurer cela, l'utilisateur peut saisir sa configuration dans un fichier de configuration, dans des fichiers RC et même dans le `package.json` de son projet. Ainsi, nous allons devoir charger l'ensemble des ces configurations et les combiner dans le bon ordre pour que l'utilisateur puisse configurer correctement notre framework.

## Installation

Pour commencer à jouer avec `c12`, nous allons l'installer. Pour cela, commençons par initialiser un nouveau projet :

```bash
mkdir c12-101
cd c12-101
npm init -y
```

Ensuite, nous allons installer `c12` :

```bash
npm install c12
```

Pour faciliter l'exécution de nos fichiers :icon{name="typescript"} TypeScript, nous allons installer [`jiti`](https://github.com/unjs/jiti) :

```bash
npm install -D jiti
```

<!-- :another-article{name="jiti-101-premiere-prise-en-main"} -->

Pour finir, nous allons créer le dossier `src` qui contiendra toutes nos sources :

```bash
mkdir src
```

## Chargement des configurations

Pour charger l'ensemble de ces configurations et les assembler ensemble, nous allons pouvoir utiliser `c12` et le configurer petit à petit. Dans l'ensemble de ce tutoriel, nous allons faire semblant de vouloir créer une application s'appelant `tnux`.

Pour commencer, nous allons créer un fichier `config.ts` dans le dossier

```bash
touch src/config.ts
```

Ensuite, nous allons pouvoir utiliser la fonction `loadConfig` de `c12` pour charger la configuration :

```ts [config.ts]
import { loadConfig } from 'c12'

export async function loadTnuxConfig() {
  const { config } = await loadConfig({
    name: 'tnux', // Permet de définir le nom des clés et fichiers de configuration qui seront recherchés par C12.
  })

  return config
}
```

Ensuite, nous allons pouvoir utiliser cette fonction dans notre fichier `index.ts` :

```ts [index.ts]
import { loadTnuxConfig } from './config'

loadTnuxConfig().then((config) => {
  console.dir(config, { depth: null })
})
```

_Parfait_ ! Nous avons réussi à charger la configuration de notre application `tnux`. Maintenant, nous allons pouvoir commencer à la configurer.

::alert{type="info"}
Pour exécuter notre script `index.ts`, nous allons devoir utiliser `jiti` pour exécuter notre fichier :icon{name="typescript"} TypeScript. Pour cela, nous allons devoir ajouter un script dans notre `package.json` :

```json [package.json]
{
  "scripts": {
    "start": "jiti src/index.ts"
  }
}
```

Pour le moment, la function ne retourne qu'un simple objet vide.
::

### Configuration par défaut

Commençons par mettre en place notre configuration par défaut pour notre application. Pour cela, nous allons pouvoir la définir directement dans la fonction `loadConfig` :

```ts [config.ts]
// ...
export async function loadTnuxConfig() {
  const { config } = await loadConfig({
    name: 'tnux',
    defaults: {
      app: {
        name: 'tnux',
        version: '0.0.1',
      },
      vite: {
        port: 3000,
      },
      tailwind: {
        themes: {
          colors: {
            primary: 'blue',
            secondary: 'gray',
          },
        },
      },
    },
  })

  return config
}
```

Maintenant, nous pouvons exécuter notre script pour voir le résultat et sans surprise, il s'agit de notre configuration par défaut ! :sunglasses:

::alert{type="info"}
Nous chargeons ici une configuration totalement arbitraire. L'idée est d'avoir une configuration que nous allons pouvoir personnaliser par la suite.
::

Notre configuration par défaut fonctionne ! Nous allons pouvoir commencer à charger une configuration utilisateur.

### Configuration du package.json

La première configuration que nous allons charger est celle présente dans le `package.json` du projet. Pour trouver cette configuration, `c12` va utiliser la clé `tnux` que nous avons défini lors du paramétrage de `c12`.

Dans notre fichier `package.json`, nous pouvons ajouter une peu de configuration :

```json [package.json]
{
  // ...
  "tnux": {
    "app": {
      "baseUrl": "/tnux"
    }
  }
}
```

Maintenant, nous allons pouvoir exécuter notre script pour voir le résultat :

```bash
npm start
```

Et nous obtenons le résultat suivant :worried: :

```js [Résultat]
{
  app: { name: 'tnux', version: '0.0.1' },
  vite: { port: 3000 },
  tailwind: { themes: { colors: { primary: 'blue', secondary: 'gray' } } }
}
```

Il manque la clé `baseURL` !

Par défaut, `c12` ne charge pas la configuration du `package.json`. Pour cela, nous allons devoir ajouter une option supplémentaire à notre fonction `loadConfig` :

```ts [config.ts]
// ...
export async function loadTnuxConfig() {
  const { config } = await loadConfig({
    name: 'tnux',
    packageJson: true, // Permet de charger la configuration du package.json.
    defaults: {
     //...
    },
  })

  return config
}
```

En ré-exécutant notre fichier, nous obtenons maintenant le bon résultat :

```js [Résultat]
{
  app: { name: 'tnux', version: '0.0.1', baseURL: '/tnux' }, // La clé baseURL est bien présente.
  vite: { port: 3000 },
  tailwind: { themes: { colors: { primary: 'blue', secondary: 'gray' } } }
}
```

### Configuration par ficher RC global

<!-- TODO: pointer vers RC9 -->

### Configuration par fichier RC local

<!-- TODO: expliquer pourquoi on veut ça et prendre l'exemple de nuxthq (regarder le script dans les actions) -->

### Configuration par fichier TS

<!-- TODO: faire un fichier tnux.config.ts -->

### Configuration par options pour surcharger

<!-- TODO: ajouter des options directement par desssus -->

## Variables d'environnement

<!-- TODO: utilisation du dotenv -->

## Étendre une configuration

<!-- TODO: parler du système de Nuxt avec le extends -->

## Configuration par environnement

<!-- TODO: parler du watch mode mais ça veut surtout dire qu'il va être important de bien comprendre comment on peut l'utiliser  -->

## Conclusion

<!-- TODO: remettre l'ordre de chargement des configurations via une liste -->

Maintenant que nous avons vu la base, les utilitaires bas niveaux, nous allons pouvoir commencer à les assembler dans des outils plus haut niveau pour faire des programmes plus complexes avec des fonctionnalités plus intéressantes. Ainsi, nous découvrirons dans la suite de cette série `citty`, un outil pour créer des applications en ligne de commande. Puis nous verrons comment créer notre propre application en ligne de commande avec `citty` et les autres outils d'UnJS.
